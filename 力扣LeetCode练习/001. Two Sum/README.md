# 题译
已知一个整型数组和目标值，从数组中取出两个元素求和，返回和等于目标值时的元素下标。
假设每组输入最多有一个解，且每个元素最多只能用一次。

# 思路
## 2018-02-07
- 两层按序遍历所有两个元素的组合，判断其和是否等于目标值。
- 内层遍历下标（记为n）应从0到length-2；外层遍历下标应从内层当前正遍历下标的下一个（即n+1）到length-1。
- 内层遍历应处于外层遍历之后，即内层遍历的起始元素的下标应是当前外层正遍历到的元素的下标之后一位。

# 回顾/对比
- 我的solution的耗时为37\~39ms，看了30\~39ms的答案，发现有些相仿的、相同的、时耗更甚（如在每个外层循环中为indexs[0]赋值，大多数循环是用不上这一步的）的方案，却比我的solution的耗时更短，不明所以，姑且理解为测试数据sample过少导致的随机性吧。
- 看了耗时为0\~15ms的优秀方案，发现分为5类：
    1. 利用HashMap的速度优势存放<value,index>，遍历数组时判断该HashMap中是否有一个key（即array的value）满足该key与此时正遍历的元素的和等于目标值。
    2. 先将数组排序，再循环从数组的左边和右边各取一个元素，若两者之和小于目标值则将“左边”右移一位再继续循环；若两者之和等于目标值，且“左边”和“右边”的index不相等，则拿这两个元素去原数组中找对应index即为所求；若两者之和大于目标值则将“右边左移一位再继续循环。
    3. 先将数组排序（使用后面方法的前提），随后遍历所有元素时利用Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key)方法，从当前正遍历元素的下一个元素开始，搜索目标值与当前正遍历元素的差，若搜索返回的index为正数（搜索到了），且该index不等于当前正遍历元素的index，则可得该被加数和加数，再利用它俩到原数组中找index即可。
    4. 明天再看4ms的那个实现
    5. 明天再看3ms的那个实现
